#include <string>
#include <iostream>
#include "olcConsoleGameEngine.h"
using namespace std;

class Frogger : public olcConsoleGameEngine
{
public:
	Frogger()
	{
		m_sAppName = L"Frogger";
	}

private:
	vector<pair<float, wstring>> vecLanes =
	{
		{ 0.0f, L"wwwhhwggwwnnwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww" }, //end
		{-3.0f, L",,jk,,,,,jlk,,,,,,,,,jllk,,,,,jk,,,jk,,,,,,,,jk,,,jlk,,,,,,,jlk," }, //logs
		{ 3.0f, L",,,jlk,,,,,,jlk,,,,jk,,,,,,,jk,,jllk,jlk,,,jlk,,,,,jlk,,,,jlk,,," }, //logs
		{ 2.0f, L",,,,,,,,,,jk,,,,,jllk,,,,,,,,,,jlk,,,,jllk,,,,,,,jlk,,,,,,,jk,,," }, //logs
		{ 0.0f, L"pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp" }, //sidewalk
		{-3.0f, L"...asdf....asdf..asdf....asdf..asdf.....asdf...asdf...asdf..asdf" }, //buses
		{-4.0f, L"......zx...zx..zx....zx.zx.zx....zx.....zx..zx.....zx....zx.zx.." }, //cars
		{ 3.0f, L"...ty....ty.ty.ty...ty..ty....ty....ty.ty....ty....ty.ty.ty...ty" }, //cars
		{ 2.0f, L"....ty..ty.....ty....ty...ty.ty...ty....ty..ty.ty...ty.....ty..." }, //cars
		{ 0.0f, L"pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp" }, //start
	};

	float fTimeSinceStart = 0.0f;
	int nCellSize = 8;
	int nLaneWidth = 18;

	float fFrogX = 8.0f;
	float fFrogY = 9.0;

	bool* bufDanger = nullptr;

	bool* home1Check = nullptr;
	bool* home2Check = nullptr;
	bool* home3Check = nullptr;
	bool* allHomeCheck = nullptr;

	olcSprite* spriteBus = nullptr;
	olcSprite* spriteLog = nullptr;
	olcSprite* spriteWater = nullptr;
	olcSprite* spriteFrog = nullptr;
	olcSprite* spriteFrog2 = nullptr;
	olcSprite* spritePavement = nullptr;
	olcSprite* spriteCar1 = nullptr;
	olcSprite* spriteCar2 = nullptr;
	olcSprite* spriteWall = nullptr;
	olcSprite* spriteHome = nullptr;

protected:
	// Called by olcConsoleGameEngine
	virtual bool OnUserCreate()
	{
		spriteBus = new olcSprite(L"FroggerSprites/bus.spr");
		spriteLog = new olcSprite(L"FroggerSprites/log.spr");
		spriteWater = new olcSprite(L"FroggerSprites/water.spr");
		spriteFrog = new olcSprite(L"FroggerSprites/frog.spr");
		spriteFrog2 = new olcSprite(L"FroggerSprites/frog.spr");
		spritePavement = new olcSprite(L"FroggerSprites/pavement.spr");
		spriteWall = new olcSprite(L"FroggerSprites/wall.spr");
		spriteHome = new olcSprite(L"FroggerSprites/home.spr");
		spriteCar1 = new olcSprite(L"FroggerSprites/car1.spr");
		spriteCar2 = new olcSprite(L"FroggerSprites/car2.spr");

		bufDanger = new bool[ScreenWidth() * ScreenHeight()];
		memset(bufDanger, 0, ScreenWidth() * ScreenHeight() * sizeof(bool));

		home1Check = new bool[ScreenWidth() * ScreenHeight()];
		memset(home1Check, 0, ScreenWidth() * ScreenHeight() * sizeof(bool));
		
		home2Check = new bool[ScreenWidth() * ScreenHeight()];
		memset(home2Check, 0, ScreenWidth() * ScreenHeight() * sizeof(bool));

		home3Check = new bool[ScreenWidth() * ScreenHeight()];
		memset(home3Check, 0, ScreenWidth() * ScreenHeight() * sizeof(bool));

		return true;
	}

	// Called by olcConsoleGameEngine
	virtual bool OnUserUpdate(float fElapsedTime)
	{
		fTimeSinceStart += fElapsedTime;

		// Handle input
		if (m_keys[VK_UP].bPressed)		fFrogY -= 1.0f;
		if (m_keys[VK_DOWN].bPressed)	fFrogY += 1.0f;
		if (m_keys[VK_LEFT].bPressed)	fFrogX -= 1.0f;
		if (m_keys[VK_RIGHT].bPressed)	fFrogX += 1.0f;

		// Frog is moved by platforms
		if (fFrogY <= 3) fFrogX -= fElapsedTime * vecLanes[(int)fFrogY].first;

		// Collision detection - check four corners of frog against danger buffer
		bool tl = bufDanger[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)];
		bool tr = bufDanger[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];
		bool bl = bufDanger[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)];
		bool br = bufDanger[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];

		// Collision detection - check four corners of frog against 3 homes
		// Home 1
		bool tl1 = home1Check[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)] ;
		bool tr1 = home1Check[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];
		bool bl1 = home1Check[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)];
		bool br1 = home1Check[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];

		// Home 2
		bool tl2 = home2Check[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)];
		bool tr2 = home2Check[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];
		bool bl2 = home2Check[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)];
		bool br2 = home2Check[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];

		// Home 3
		bool tl3 = home3Check[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)];
		bool tr3 = home3Check[(int)(fFrogY * nCellSize + 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];
		bool bl3 = home3Check[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)(fFrogX * nCellSize + 1)];
		bool br3 = home3Check[(int)((fFrogY + 1) * nCellSize - 1) * ScreenWidth() + (int)((fFrogX + 1) * nCellSize - 1)];


		// Home 1 Reached
		if (tl1 || tr1 || bl1 || br1)
		{
			fFrogX = 8.0f;
			fFrogY = 9.0f;
		}
		// Home 2 Reached
		if (tl2 || tr2 || bl2 || br2)
		{
			fFrogX = 8.0f;
			fFrogY = 9.0f;
		}
		// Home 3 Reached
		if (tl3 || tr3 || bl3 || br3)
		{
			fFrogX = 8.0f;
			fFrogY = 9.0f;
		}
			
		// Frogs been hit
		if (tl || tr || bl || br)
		{
			fFrogX = 8.0f;
			fFrogY = 9.0f;
		}

		//Draw Lanes
		int x = -1, y = 0;
		for (auto lane : vecLanes)
		{
			// Find offset start
			int nStartPos = (int)(fTimeSinceStart * lane.first) % 64;
			int nCellOffset = (int)((float)nCellSize * fTimeSinceStart * lane.first) % nCellSize;
			if (nStartPos < 0)	nStartPos = 64 - (abs(nStartPos) % 64);

			for (int i = 0; i < nLaneWidth; i++)
			{
				//Draw Graphics
				wchar_t graphic = lane.second[(nStartPos + i) % 64];
				//Fill((x + i) * nCellSize - nCellOffset, y * nCellSize, (x + i + 1) * nCellSize - nCellOffset, (y + 1) * nCellSize, graphic);

				switch (graphic) // Graphics always make code verbose and less clear
				{
				case L'a':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteBus, 0, 0, 8, 8);		break; // Bus 1
				case L's':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteBus, 8, 0, 8, 8);		break; // Bus 2
				case L'd':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteBus, 16, 0, 8, 8);	break; // Bus 3
				case L'f':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteBus, 24, 0, 8, 8);	break; // Bus 4

				case L'j':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteLog, 0, 0, 8, 8);		break; // Log Start
				case L'l':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteLog, 8, 0, 8, 8);		break; // Log Middle
				case L'k':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteLog, 16, 0, 8, 8);	break; // Log End

				case L'z': 	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteCar1, 0, 0, 8, 8);	break; // Car1 Back
				case L'x':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteCar1, 8, 0, 8, 8);	break; // Car1 Front

				case L't': 	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteCar2, 0, 0, 8, 8);	break; // Car2 Back
				case L'y': 	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteCar2, 8, 0, 8, 8);	break; // Car2 Front

				case L'w': 	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteWall, 0, 0, 8, 8);	break; // Wall
				case L'h':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteHome, 0, 0, 8, 8);	break; // Home 1
				case L'g':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteHome, 0, 0, 8, 8);	break; // Home 2
				case L'n':	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteHome, 0, 0, 8, 8);	break; // Home 3
				case L',': 	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spriteWater, 0, 0, 8, 8);	break; // Water
				case L'p': 	DrawPartialSprite((x + i) * nCellSize - nCellOffset, y * nCellSize, spritePavement, 0, 0, 8, 8); break; // Pavement
				case L'.': 	Fill((x + i) * nCellSize - nCellOffset, y * nCellSize, (x + i + 1) * nCellSize - nCellOffset, (y + 1) * nCellSize, L' ');	break;
				}

				// Fill Danger Buffer
				for (int j = (x + i) * nCellSize - nCellOffset; j < (x + i + 1) * nCellSize - nCellOffset; j++)
					for (int k = y * nCellSize; k < (y + 1) * nCellSize; k++)
						if (j >= 0 && j < ScreenWidth() && k >= 0 && k < ScreenHeight())
							bufDanger[k * ScreenWidth() + j] =
							!(graphic == L'.' ||										// Road
							graphic == L'j' || graphic == L'k' || graphic == L'l' ||	// Logs
							graphic == L'p' ||											// Pavement
							graphic == L'h' || graphic == L'g' || graphic == L'n');		// Homes

				// Fill Home 1 Buffer
				for (int j = (x + i) * nCellSize - nCellOffset; j < (x + i + 1) * nCellSize - nCellOffset; j++)
					for (int k = y * nCellSize; k < (y + 1) * nCellSize; k++)
						if (j >= 0 && j < ScreenWidth() && k >= 0 && k < ScreenHeight())
							home1Check[k * ScreenWidth() + j] =
							(graphic == L'h');


				// Fill Home 2 Buffer
				for (int j = (x + i) * nCellSize - nCellOffset; j < (x + i + 1) * nCellSize - nCellOffset; j++)
					for (int k = y * nCellSize; k < (y + 1) * nCellSize; k++)
						if (j >= 0 && j < ScreenWidth() && k >= 0 && k < ScreenHeight())
							home2Check[k * ScreenWidth() + j] =
							(graphic == L'g');
				
				// Fill Home 3 Buffer
				for (int j = (x + i) * nCellSize - nCellOffset; j < (x + i + 1) * nCellSize - nCellOffset; j++)
					for (int k = y * nCellSize; k < (y + 1) * nCellSize; k++)
						if (j >= 0 && j < ScreenWidth() && k >= 0 && k < ScreenHeight())
							home3Check[k * ScreenWidth() + j] =
							(graphic == L'n');

			}
			y++;
		}

		// Draw Frog
		DrawSprite(fFrogX * nCellSize, fFrogY * nCellSize, spriteFrog);

		return true;
	}
};

int main()
{
	// Use olcConsoleGameEngine derived app
	Frogger game;
	game.ConstructConsole(128, 80, 12, 12);
	game.Start();
	return 0;
}
